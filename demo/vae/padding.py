"""Tensor padding of 1D and 2D tensors, based on local constant, linear and quadratic extrapolation."""

__all__ = ["pad_constant_2d", "pad_constant_2d_one",
           "pad_linear_2d", "pad_linear_2d_one",
           "pad_quadratic_2d", "pad_quadratic_2d_one",
           "pad_constant_1d", "pad_constant_1d_one",
           "pad_linear_1d", "pad_linear_1d_one",
           "pad_quadratic_1d", "pad_quadratic_1d_one"]

import tensorflow as tf


@tf.function
def _assemble_padded_2d(*, interior: tf.Tensor,
                        top: tf.Tensor, bottom: tf.Tensor, left: tf.Tensor, right: tf.Tensor,
                        top_left: float, top_right: float, bottom_left: float, bottom_right: float) -> tf.Tensor:
    """Assemble a padded rank-2 tensor from parts.

    `interior`: rank-2 tensor, [nrows, ncols]; original tensor to which the padding is to be added
    `top`, `bottom`: rank-1 tensors, [ncols] each; padding edge values
    `left`, `right`: rank-1 tensors, [nrows] each; padding edge values
    `top_left`, `top_right`, `bottom_left`, `bottom_right`: scalars; padding corner values

    Return value is a rank-2 tensor, populated as follows::

        TL T T T T TR
         L i i i i R
         L i i i i R
         L i i i i R
        BL B B B B BR
    """
    # 1) Assemble padded top and bottom edges, with corners.
    ult = tf.expand_dims(top_left, axis=0)  # [] -> [1]
    urt = tf.expand_dims(top_right, axis=0)
    fulltop = tf.concat([ult, top, urt], axis=0)  # e.g. [256] -> [258]
    fulltop = tf.expand_dims(fulltop, axis=0)  # [258] -> [1, 258]
    llt = tf.expand_dims(bottom_left, axis=0)
    lrt = tf.expand_dims(bottom_right, axis=0)
    fullbottom = tf.concat([llt, bottom, lrt], axis=0)
    fullbottom = tf.expand_dims(fullbottom, axis=0)

    # 2) Assemble middle part, padding left and right.
    left = tf.expand_dims(left, axis=-1)  # [256] -> [256, 1]
    right = tf.expand_dims(right, axis=-1)
    widened = tf.concat([left, interior, right], axis=1)  # [256, 256] -> [256, 258]

    # 3) Assemble the final tensor.
    padded = tf.concat([fulltop, widened, fullbottom], axis=0)  # -> [258, 258]
    return padded

@tf.function
def _assemble_padded_1d(*, interior: tf.Tensor, left: float, right: float) -> tf.Tensor:
    """Like `_assemble_padded_2d`, but for 1D tensor.

    The return value is populated as follows::

        L i i i R
    """
    left = tf.expand_dims(left, axis=0)  # [] -> [1]
    right = tf.expand_dims(right, axis=0)
    padded = tf.concat([left, interior, right], axis=0)  # e.g. [256] -> [258]
    return padded


@tf.function(reduce_retracing=True)
def pad_constant_2d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by one grid unit, by copying the nearest value from the edges.

    `f`: data in meshgrid format.

    This is really "nearest", but "constant" in the sense of the other paddings defined here:
    we estimate the function value as locally constant.

    The corner paddings are generated by applying the same idea diagonally.
    """
    top = f[0, :]
    bottom = f[-1, :]
    left = f[:, 0]
    right = f[:, -1]

    tl = f[0, 0]
    tr = f[0, -1]
    bl = f[-1, 0]
    br = f[-1, -1]

    return _assemble_padded_2d(interior=f, top=top, bottom=bottom, left=left, right=right,
                               top_left=tl, top_right=tr, bottom_left=bl, bottom_right=br)

@tf.function(reduce_retracing=True)
def pad_constant_1d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 1D tensor by one grid unit, by copying the nearest value from the edges."""
    left = f[0]
    right = f[-1]
    return _assemble_padded_1d(interior=f, left=left, right=right)

@tf.function(reduce_retracing=True)
def pad_linear_2d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by one grid unit, by linear extrapolation.

    `f`: data in meshgrid format.

    For example, if the layout at the end of a row is::

      f0 f1 | f2

    where f2 is to be created by extrapolation, then::

      f2 = f1 + Δf
         = f1 + [f1 - f0]
         = 2 f1 - f0

    where we estimate the first difference Δf as locally constant; or in other words,
    we estimate the function value itself as locally linear::

      Δf := f1 - f0 = f2 - f1

    The corner paddings are generated by applying the same idea diagonally.
    """
    top = 2 * f[0, :] - f[1, :]
    bottom = 2 * f[-1, :] - f[-2, :]
    left = 2 * f[:, 0] - f[:, 1]
    right = 2 * f[:, -1] - f[:, -2]

    tl = 2 * f[0, 0] - f[1, 1]
    tr = 2 * f[0, -1] - f[1, -2]
    bl = 2 * f[-1, 0] - f[-2, 1]
    br = 2 * f[-1, -1] - f[-2, -2]

    return _assemble_padded_2d(interior=f, top=top, bottom=bottom, left=left, right=right,
                               top_left=tl, top_right=tr, bottom_left=bl, bottom_right=br)

@tf.function(reduce_retracing=True)
def pad_linear_1d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by one grid unit, by linear extrapolation."""
    left = 2 * f[0] - f[1]
    right = 2 * f[-1] - f[-2]
    return _assemble_padded_1d(interior=f, left=left, right=right)

@tf.function(reduce_retracing=True)
def pad_quadratic_2d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by one grid unit, by quadratic extrapolation.

    `f`: data in meshgrid format.

    For example, if the layout at the end of a row is::

      f0 f1 f2 | f3

    where f3 is to be created by extrapolation, then::

      f3 = f2 + Δf_23

    where we estimate the first difference Δf as locally linear; or in other words,
    we estimate the function value itself as locally quadratic::

      Δf_23 = Δf_12 + [Δf_12 - Δf_01]
            = 2 Δf_12 - Δf_01
            ≡ 2 [f2 - f1] - [f1 - f0]
            = 2 f2 - 3 f1 + f0

    so finally::

      f3 = f2 + [2 f2 - 3 f1 + f0]
         = 3 f2 - 3 f1 + f0

    The corner paddings are generated by applying the same idea diagonally.
    """
    top = 3 * f[0, :] - 3 * f[1, :] + f[2, :]
    bottom = 3 * f[-1, :] - 3 * f[-2, :] + f[-3, :]
    left = 3 * f[:, 0] - 3 * f[:, 1] + f[:, 2]
    right = 3 * f[:, -1] - 3 * f[:, -2] + f[:, -3]

    tl = 3 * f[0, 0] - 3 * f[1, 1] + f[2, 2]
    tr = 3 * f[0, -1] - 3 * f[1, -2] + f[2, -3]
    bl = 3 * f[-1, 0] - 3 * f[-2, 1] + f[-3, 2]
    br = 3 * f[-1, -1] - 3 * f[-2, -2] + f[-3, -3]

    return _assemble_padded_2d(interior=f, top=top, bottom=bottom, left=left, right=right,
                               top_left=tl, top_right=tr, bottom_left=bl, bottom_right=br)

@tf.function(reduce_retracing=True)
def pad_quadratic_1d_one(f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by one grid unit, by quadratic extrapolation."""
    left = 3 * f[0] - 3 * f[1] + f[2]
    right = 3 * f[-1] - 3 * f[-2] + f[-3]
    return _assemble_padded_1d(interior=f, left=left, right=right)

@tf.function
def pad_constant_2d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by `n` grid units, by copying the nearest value from the edges.

    `n`: how many grid units to pad by.
    `f`: data in meshgrid format.
    """
    for _ in range(n):
        # This triggers retracing at each enlargement if we don't use `reduce_retracing=True`.
        f = pad_constant_2d_one(f)
    return f

@tf.function
def pad_constant_1d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 1D tensor by `n` grid units, by copying the nearest value from the edges."""
    for _ in range(n):
        f = pad_constant_1d_one(f)
    return f

@tf.function
def pad_linear_2d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by `n` grid units, by linear extrapolation.

    `n`: how many grid units to pad by.
    `f`: data in meshgrid format.
    """
    for _ in range(n):
        f = pad_linear_2d_one(f)
    return f

@tf.function
def pad_linear_1d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 1D tensor by `n` grid units, by linear extrapolation."""
    for _ in range(n):
        f = pad_linear_1d_one(f)
    return f

@tf.function
def pad_quadratic_2d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 2D tensor by `n` grid units, by quadratic extrapolation.

    `n`: how many grid units to pad by.
    `f`: data in meshgrid format.
    """
    for _ in range(n):
        f = pad_quadratic_2d_one(f)
    return f

@tf.function
def pad_quadratic_1d(n: int, f: tf.Tensor) -> tf.Tensor:
    """Pad 1D tensor by `n` grid units, by quadratic extrapolation."""
    for _ in range(n):
        f = pad_quadratic_1d_one(f)
    return f
