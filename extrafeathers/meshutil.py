# -*- coding: utf-8; -*-
"""Gmsh import for FEniCS, built on top of meshio.

Based on many posts in these discussion threads:
  https://fenicsproject.discourse.group/t/converting-simple-2d-mesh-from-gmsh-to-dolfin/583/4
  https://fenicsproject.discourse.group/t/transitioning-from-mesh-xml-to-mesh-xdmf-from-dolfin-convert-to-meshio/412/9
"""

__all__ = ["import_gmsh", "read_hdf5_mesh"]

import pathlib
import tempfile
import typing

import numpy as np

import meshio

import dolfin

# names for the datasets in the output files
mesh_dataset = "mesh"
cell_dataset = "domain_parts"
boundary_dataset = "boundary_parts"

def _absolute_path(filename_or_path: typing.Union[pathlib.Path, str]) -> pathlib.Path:
    return pathlib.Path(filename_or_path).expanduser().resolve()

# https://fenicsproject.discourse.group/t/transitioning-from-mesh-xml-to-mesh-xdmf-from-dolfin-convert-to-meshio/412/104
def _stack_cells(msh: meshio.Mesh, type: str):
    """From `msh`, concatenate all cells of given `type` into one big `np.array`.

    Some mesh files may have several cell blocks of the same type,
    but FEniCS expects just one.

    `type`: e.g. "line", "triangle", or "tetra".
    """
    cells = np.vstack(np.array([block.data for block in msh.cells
                                if block.type == type]))
    return cells


def import_gmsh(src: typing.Union[pathlib.Path, str],
                dst: typing.Union[pathlib.Path, str]) -> None:
    """Import a Gmsh mesh into FEniCS.

    Physical boundaries are also imported.

    Simplicial meshes (triangles/tetrahedrons) only.

    `src`: The `.msh` file to import.
    `dst`: The `.h5` file to write.

    The output is a single HDF5 file with three groups:
      - "/mesh" contains the mesh itself
      - "/domain_parts" contains the physical cells
        (i.e. surfaces in 2D, volumes in 3D), if the
        input file specifies any.
      - "/boundary_parts" contains the physical facets
        (i.e. lines in 2D, surfaces in 3D), if the
        input file specifies any.

    If the same cell or facet has multiple tags, the latest one wins.

    The resulting HDF5 file can be read back in using `read_hdf5_mesh`.
    """
    if dolfin.MPI.comm_world.size > 1:
        raise NotImplementedError("`import_gmsh` does not support running in parallel. Perform the mesh file conversion serially, then run your solver in parallel.")

    src = _absolute_path(src)
    dst = _absolute_path(dst)

    output_directory = dst.parent
    output_directory.mkdir(exist_ok=True)

    # Read input mesh (generated by Gmsh)
    msh = meshio.read(src)
    dim = 3 if "tetra" in msh.cells_dict else 2  # TODO: brittle?

    if dim == 2:
        # Force geometric dimension of mesh to 2D by deleting z coordinate
        msh.points = msh.points[:, :2]

    cell_kind = "triangle" if dim == 2 else "tetra"
    facet_kind = "line" if dim == 2 else "triangle"

    # Convert geometry to XDMF
    with tempfile.NamedTemporaryFile() as temp_mesh_out:
        # meshio expects a pathlike, not a buffer directly.
        # print(meshio._helpers.extension_to_filetype)
        #
        # "Whether the name can be used to open the file a second time, while the
        # named temporary file is still open, varies across platforms (it can be so
        # used on Unix; it cannot on Windows NT or later)."
        #   --https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile
        meshio.write(temp_mesh_out.name,
                     meshio.Mesh(points=msh.points,
                                 cells={cell_kind: _stack_cells(msh, cell_kind)}),
                     file_format="xdmf")

        # Read the temporary XDMF into FEniCS internal format.
        #
        # XDMFFile is a wrapper for C++ code so it's safe to assume it
        # doesn't support Python filelikes. So pass in the filename here too...
        mesh = dolfin.Mesh()
        with dolfin.XDMFFile(temp_mesh_out.name) as temp_mesh_in:
            temp_mesh_in.read(mesh)
        # print(f"Read mesh with topological dimension {mesh.topology().dim()} and geometric dimension {mesh.geometric_dimension()}.")  # DEBUG

    # Convert Gmsh physical facets (lines in 2D, surfaces in 3D) to XDMF
    with tempfile.NamedTemporaryFile() as boundary_parts_out:
        meshio.write(boundary_parts_out.name,
                     meshio.Mesh(points=msh.points,
                                 cells={facet_kind: msh.cells_dict[facet_kind]},
                                 cell_data={boundary_dataset: [msh.cell_data_dict["gmsh:physical"][facet_kind]]}),
                     file_format="xdmf")

        # MeshValueCollection represents imported data, which can be
        # then loaded into a MeshFunction the solver can use.
        # https://fenicsproject.discourse.group/t/difference-between-meshvaluecollection-and-meshfunction/5219
        #
        # Note any facet not present in the MeshValueCollection will be tagged with a large number:
        # size_t(-1) = 2**64 - 1 = 18446744073709551615
        # https://fenicsproject.discourse.group/t/transitioning-from-mesh-xml-to-mesh-xdmf-from-dolfin-convert-to-meshio/412/35
        mvc = dolfin.MeshValueCollection("size_t", mesh, mesh.topology().dim() - 1)
        with dolfin.XDMFFile(boundary_parts_out.name) as boundary_parts_in:
            boundary_parts_in.read(mvc, boundary_dataset)
        mf = dolfin.MeshFunction("size_t", mesh, mvc)

    # Convert Gmsh physical cells (surfaces in 2D, volumes in 3D) to XDMF
    with tempfile.NamedTemporaryFile() as domain_parts_out:
        meshio.write(domain_parts_out.name,
                     meshio.Mesh(points=msh.points,
                                 cells={cell_kind: msh.cells_dict[cell_kind]},
                                 cell_data={cell_dataset: [msh.cell_data_dict["gmsh:physical"][cell_kind]]}),
                     file_format="xdmf")

        mvc = dolfin.MeshValueCollection("size_t", mesh, mesh.topology().dim())
        with dolfin.XDMFFile(domain_parts_out.name) as domain_parts_in:
            domain_parts_in.read(mvc, cell_dataset)
        cf = dolfin.MeshFunction("size_t", mesh, mvc)

    # Write the final HDF5 file
    with dolfin.HDF5File(mesh.mpi_comm(), str(dst), "w") as hdf:
        hdf.write(mesh, f"/{mesh_dataset}")  # the mesh itself
        hdf.write(cf, f"/{cell_dataset}")  # MeshFunction on cells of `mesh`
        hdf.write(mf, f"/{boundary_dataset}")  # MeshFunction on facets of `fluid_mesh`


# # Some assumptions in this function, which is otherwise very nice, seem to be a little different from ours.
# # By Dokken, from
# # https://fenicsproject.discourse.group/t/transitioning-from-mesh-xml-to-mesh-xdmf-from-dolfin-convert-to-meshio/412/158
# def create_entity_mesh(mesh, cell_type, prune_z=False,
#                        remove_unused_points=False,
#                        name_to_read="name_to_read"):
#     """
#     Given a meshio mesh, extract mesh and physical markers for a given entity.
#     We assume that all unused points are at the end of the mesh.points
#     (this happens when we use physical markers with pygmsh)
#     """
#     cells = mesh.get_cells_type(cell_type)
#     try:
#         # If mesh created with gmsh API it is simple to extract entity data
#         cell_data = mesh.get_cell_data("gmsh:physical", cell_type)
#     except KeyError:
#         # If mesh created with pygmsh, we need to parse through cell sets and sort the data
#         cell_entities = []
#         cell_data = []
#         cell_sets = mesh.cell_sets_dict
#         for marker, set in cell_sets.items():
#             for type, entities in set.items():
#                 if type == cell_type:
#                     cell_entities.append(entities)
#                     cell_data.append(np.full(len(entities), int(marker)))
#         cell_entities = np.hstack(cell_entities)
#         sorted = np.argsort(cell_entities)
#         cell_data = np.hstack(cell_data)[sorted]
#     if remove_unused_points:
#         num_vertices = len(np.unique(cells.reshape(-1)))
#         # We assume that the mesh has been created with physical tags,
#         # then unused points are at the end of the array
#         points = mesh.points[:num_vertices]
#     else:
#         points = mesh.points
#
#     # Create output mesh
#     out_mesh = meshio.Mesh(points=points, cells={cell_type: cells},
#                            cell_data={name_to_read: [cell_data]})
#     if prune_z:
#         out_mesh.prune_z_0()
#     return out_mesh


def read_hdf5_mesh(filename: str) -> typing.Tuple[dolfin.Mesh, dolfin.MeshFunction, dolfin.MeshFunction]:
    """Read an HDF5 mesh file created using `import_gmsh`.

    The return value is `(mesh, domain_parts, boundary_parts)`.

    Raises `ValueError` if the file does not have a "/mesh" group.

    If the file does not have a "/domain_parts" or "/boundary_parts" group,
    that component of the return value will be `None`.
    """
    with dolfin.HDF5File(dolfin.MPI.comm_world, filename, "r") as hdf:
        if not hdf.has_dataset(mesh_dataset):
            raise ValueError(f"{mesh_dataset} dataset not found in mesh file {filename}")

        mesh = dolfin.Mesh()
        hdf.read(mesh, mesh_dataset, False)  # target_object, data_path_in_hdf, use_existing_partitioning_if_any

        if hdf.has_dataset(cell_dataset):
            # For the tags, we must specify which mesh the MeshFunction belongs to,
            # and the function's cell dimension.
            domain_parts = dolfin.MeshFunction('size_t', mesh, mesh.topology().dim(), 0)  # type, mesh, dim, [default_value]
            hdf.read(domain_parts, cell_dataset)
        else:
            domain_parts = None

        if hdf.has_dataset(boundary_dataset):
            boundary_parts = dolfin.MeshFunction('size_t', mesh, mesh.topology().dim() - 1, 0)
            hdf.read(boundary_parts, boundary_dataset)
        else:
            boundary_parts = None

    return mesh, domain_parts, boundary_parts
