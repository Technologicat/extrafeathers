# -*- coding: utf-8; -*-
"""Plotting utilities for FEniCS, using `matplotlib` as the backend.

We provide some "extra batteries" (i.e. features oddly missing from FEniCS itself)
for some common plotting tasks in 2D solvers:

- `mpiplot` allows a solver on a triangle mesh to plot the *whole* solution
  in the root process while running in MPI mode. This is often useful for
  debugging and visualizing simulation progress, especially for light MPI jobs
  that run locally on a laptop.

- `plot_facet_meshfunction` does exactly as it says on the tin. This is often
  useful for debugging and visualization when generating and importing meshes;
  it allows to check whether the boundaries have been tagged as expected.
"""

__all__ = ["pause",
           "as_mpl_triangulation",
           "mpiplot_prepare", "mpiplot", "mpiplot_mesh",
           "plot_facet_meshfunction"]

from collections import defaultdict
from enum import IntEnum
import typing

import numpy as np
import matplotlib as mpl
import matplotlib.tri as mtri
import matplotlib.collections as mcoll
import matplotlib.pyplot as plt

import dolfin

from .meshmagic import all_cells, my_cells, nodes_to_array, quad_to_tri, collapse_node_numbering


# Use `matplotlib`'s default color sequence.
# https://matplotlib.org/stable/gallery/color/named_colors.html
# https://matplotlib.org/stable/tutorials/intermediate/color_cycle.html
colors = [item["color"] for item in mpl.rcParams["axes.prop_cycle"]]

# Mix translucent versions. `colors` must be in "#rrggbb" format for this to work.
def _colors_with_alpha(aa):
    return [f"{color}{aa}" for color in colors]
colors20 = _colors_with_alpha("20")
colors40 = _colors_with_alpha("40")


def pause(interval: float) -> None:
    """Redraw the current Matplotlib figure **without stealing focus**.

    **IMPORTANT**:

    Works after `plt.show()` has been called at least once.

    **Background**:

    Matplotlib (3.3.3) has a habit of popping the figure window to top when it
    is updated using show() or pause(), which effectively prevents using the
    machine for anything else while a simulation is in progress.

    On some systems, it helps to force Matplotlib to use the "Qt5Agg" backend:
        https://stackoverflow.com/questions/61397176/how-to-keep-matplotlib-from-stealing-focus

    but on some others (Linux Mint 20.1) also that backend steals focus.

    One option is to use a `FuncAnimation`, but it has a different API from
    just plotting regularly, and it is not applicable in all cases.

    So, we provide this a custom non-focus-stealing pause function hack,
    based on the StackOverflow answer by user @ImportanceOfBeingErnest:
        https://stackoverflow.com/a/45734500
    """
    backend = plt.rcParams['backend']
    if backend in mpl.rcsetup.interactive_bk:
        figManager = mpl._pylab_helpers.Gcf.get_active()
        if figManager is not None:
            canvas = figManager.canvas
            if canvas.figure.stale:
                canvas.draw_idle()
            canvas.start_event_loop(interval)


def as_mpl_triangulation(V: dolfin.FunctionSpace, *,
                         mpi_global: bool = True,
                         refine: bool = False) -> typing.Optional[mtri.Triangulation]:
    """Represent the mesh of a `FunctionSpace` in Matplotlib format.

    2D meshes only.

    The `FunctionSpace` should be scalar. `.sub(j)` of a vector or tensor
    function space is fine.

    `mpi_global`: If `True`, get the whole mesh.

                  If `False`, get the MPI-local mesh part. If this MPI process
                  has no cells, the return value is `(None, None)`.

    `refine`: If `True`, and `V` has degree higher than 1 (i.e. 2 or 3),
              get the linear visualization cells (generated by `extrafeathers`).

              If `False`, get the original cells. DOFs on the edges and interior
              will be ignored.

    Return value is `(polys, tris)`, where:

      - `polys` is a `matplotlib.collections.PolyCollection`.

        The cell type is the same as for the original mesh; quadrilateral meshes
        produce quadrilateral `polys`.

        Can be used to plot the edges (to adjust color, use `polys.set_edgecolor(c)`)
        and to visualize dG0 functions (use `polys.set_facecolors(c)` to set the data,
        one value per cell). Use `ax.add_collection(polys)` to add `polys` to an axes
        to actually show it. (If you haven't explicitly created an axes object, use
        `ax = plt.gca()`.)

      - `tris` is `matplotlib.triangulation.Triangulation`.

        Can be used for degree 1 and higher function visualization using `tricontourf`
        and `tripcolor`. If needed, the triangulation itself can be visualized using
        `triplot`.

        **Quadrilateral meshes**:

        Because Matplotlib does not support unstructured quadrilateral meshes,
        we convert any quadrilateral mesh into a crossed-diagonal triangulation.
        This has 4× as many cells and asymptotically 2× as many DOFs as the original,
        but it is only meant for use in visualization, so it shouldn't matter.

        The added global DOFs (cell centers) are tacked on to the end of the global
        DOF numbering, one per cell, in the same order as `all_cells` or `my_cells`
        extracts the cells.

        If `refine=True`, the conversion is applied to the refined mesh. Hence e.g.
        a Q3 mesh will produce a triangulation with 36× as many triangles as the
        original quads (9× from Q3->Q1 and then a further 4× from Q1->P1). In the
        conversion, each linear visualization quad will get its own additional DOF
        at the center of the *visualization quad*.

        If `refine=False`, the conversion is applied to the original mesh.
        Each original quad will get just one additional DOF at the cell center.

        Note that when using the triangulation to interpolate a FEM function on
        quadrilaterals, you will need to produce the additional DOF values and
        then concatenate those to the (subspace-relevant part of the) original
        DOF vector.

        For degrees 2 and 3 this can be tricky and/or slow; but for degree 1 there
        is a native-speed shortcut. Project or interpolate your function into a
        dG0 space on your original mesh, thereby obtaining the cell center values.

        (There is a way, using `prepare_linear_export` and some manual DOF copying;
         then the function can be projected to dG0 on the Q1 "export" mesh to quickly
         compute the vis cell center DOFs. Then map the cell center DOFs back to
         the DOFs of the triangulation, using a geometric search like `map_refined`
         does. This is however not implemented, at least yet.)
    """
    cell_kind = str(V.ufl_element().cell())
    if cell_kind not in ("triangle", "quadrilateral"):
        raise ValueError(f"Expected `V` to be defined on a triangle or quadrilateral mesh; got '{cell_kind}'.")

    # Before proceeding, renumber the DOFs into a contiguous zero-based range.
    #
    # The fully general case is when `V` is on a `MixedElement` with several
    # vector/tensor field, and the quantity of interest lives on `V.sub(j).sub(k)`
    # (field `j`, component `k`).
    try:
        V = V.collapse()
    except RuntimeError:  # not a subspace
        pass

    # TODO: Support dG0 spaces properly. We need to construct a degree-1 space
    # TODO: to get the element edges, and then we can ignore the triangulation.

    # The cells for the MPI-local mesh part use the global DOF numbers, but refer
    # also to unowned nodes. Thus we must get a copy of the full global DOF and
    # coordinate data even if we want to construct just an MPI-local mesh part.
    our_cells, our_nodes = all_cells(V, matplotlibize=True, refine=refine)

    # Now get the relevant mesh part. We actually only need the cells; we can
    # ignore the DOF/coordinate data, since we already have a full copy (from the
    # global scan).
    if mpi_global:
        cells, ignored_nodes_dict = our_cells, our_nodes
    else:
        cells, ignored_nodes_dict = my_cells(V, matplotlibize=True, refine=refine)

    if not len(cells):
        return None, None

    # Element edges and dG0 function visualization - triangles/quadrilaterals both ok.
    # For p > 1, in FEniCS the vertices are the first DOFs in each cell.
    n = 4 if cell_kind == "quadrilateral" else 3
    vertices = [[our_nodes[dof] for dof in cell[:n]] for cell in cells]
    if cell_kind == "quadrilateral":
        # Matplotlib expects a walk around the perimeter,
        # but FEniCS numbers the Q1 DOFs as:
        #   2-3
        #   | |
        #   0-1
        # so we must flip the last two.
        vertices = [[v[0], v[1], v[3], v[2]] for v in vertices]
    polys = mcoll.PolyCollection(vertices)

    # Degree 1 or higher function visualization needs a triangulation for
    # `tricontourf`, `tripcolor`.
    if cell_kind == "quadrilateral":
        triangles, nodes = quad_to_tri(cells, our_nodes, mpi_global)
    else:  # cell_kind == "triangle":
        triangles, nodes = cells, our_nodes

    # Although we collapsed `V`, the DOFs we got are not necessarily in a
    # zero-based consecutive range, because:
    #
    #  - If `mpi_global=False`, each process gets just some of the global DOFs of `V`.
    #    Hence only one of the ranges (the one at MPI rank 0) begins at zero.
    #
    #  - `quad_to_tri` adds new DOFs that are globally unique across MPI processes.
    #    This splits the range of DOFs in each process into two subranges (original
    #    and added), each of which is consecutive, but with a gap between them.
    #
    # The triangulation needs a zero-based consecutive range, so we collapse now.
    dofs, nodes = nodes_to_array(nodes)
    triangles = collapse_node_numbering(triangles, dofs)

    # For p > 1, in FEniCS the vertices are the first DOFs in each cell,
    # hence the cat smiley.
    tris = mtri.Triangulation(nodes[:, 0], nodes[:, 1], triangles=triangles[:, :3])

    return polys, tris


def mpiplot_prepare(u: typing.Union[dolfin.Function, dolfin.Expression]) -> typing.Tuple[dolfin.FunctionSpace,
                                                                                         mcoll.PolyCollection,
                                                                                         mtri.Triangulation,
                                                                                         np.array]:
    """Optional performance optimization for `mpiplot`.

    Allows re-using the mesh and dofmap analysis across several plots.

    This converts the function space `V = u.function_space()` (which must be scalar;
    `.sub(j)` of a vector/tensor space is ok) to a Matplotlib triangulation for plotting.
    Also, if `V` is a subspace (vector/tensor field component), determines which global
    DOFs belong to `V`.

    The return value is the tuple `prep = (V, polys, tris, subspace_dofs)`.

      - This tuple can be passed into `mpiplot` as the `prep` argument.

      - The `tris` item can also be passed into `mpiplot_mesh` as the
        `_polys` argument.

    The returned `prep` remains valid for any function on the same space `V` and the
    same mesh. (Moving the mesh nodes invalidates the `prep`, but this is not checked.)
    """
    V = u.function_space()
    mesh = V.mesh()
    cell_kind = mesh.cell_name()

    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"mpiplot_prepare currently only supports meshes of topological dimension 2, got {mesh.topology().dim()}")
    if cell_kind not in ("triangle", "quadrilateral"):
        raise NotImplementedError(f"Expected 'triangle' or 'quadrilateral' cells in mesh, got '{cell_kind}'")

    element = V.ufl_element()
    family = str(element.family())
    degree = element.degree()
    if degree not in (0, 1, 2, 3) or family not in ("Lagrange",
                                                    "Discontinuous Lagrange",
                                                    "Q",
                                                    "DQ"):
        raise ValueError(f"Expected `u` to use a P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, or DQ3 element, got '{element.family()}' with degree {element.degree()}")

    # The global DOF vector always refers to the complete function space.
    # If `V` is a subspace (vector/tensor field component), the DOF vector
    # will include also those DOFs that are not part of `V`. Determine the
    # DOFs that belong to `V`.
    dofmaps = dolfin.MPI.comm_world.allgather(V.dofmap().dofs())

    # CAUTION: `all_cells`, used by `as_mpl_triangulation`,
    # sorts the nodes by global DOF number; match the ordering.
    subspace_dofs = np.sort(np.concatenate(dofmaps))

    polys, tris = as_mpl_triangulation(V, refine=True)  # this converts to degree 1

    return V, polys, tris, subspace_dofs


# TODO: not sure what exactly `matplotlib.pyplot.tricontourf` returns or what the type spec for it should be.
# The point of the Optional return value is to make it explicit it's something-or-None.
def mpiplot(u: typing.Union[dolfin.Function, dolfin.Expression], *,
            show_mesh: bool = False,
            show_partitioning: bool = False,
            prep: typing.Optional[typing.Tuple[dolfin.FunctionSpace,
                                               mtri.Triangulation,
                                               np.array]] = None,
            **kwargs: typing.Any) -> typing.Optional[typing.Any]:
    """Like `dolfin.plot`, but plots the whole field in the root process (MPI rank 0).

    `u`: `dolfin.Function`; a 2D scalar FEM field
         (`.sub(j)` of a vector or tensor field is fine)

    `show_mesh`: if `True`, show the element edges (and P1 vis edges too,
                 if `u` is a `P2` or `P3` function).

    `show_partitioning`: Used only if `show_mesh=True`.
                     If `True`, color-code the mesh parts for different MPI ranks.
                     You can use `matplotlib.pyplot.legend` to show which is which.

    `prep`: optional performance optimization, see `mpiplot_prepare` to generate this.

            This is useful if you intend to plot many functions that live on the same
            function space (or the same function at many timesteps), because a static
            mesh and the DOF mapping only need to be analyzed once.

    `kwargs`: passed through to `matplotlib.pyplot.tricontourf`

    If `u` lives on P2 or P3 elements, each element will be internally split into
    P1 triangles for visualization.

    In the root process (MPI rank 0), returns the plot object.
    See the return value of `matplotlib.pyplot.tricontourf`.

    In other processes, returns `None`.
    """
    V = u.function_space()
    mesh = V.mesh()
    cell_kind = mesh.cell_name()

    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"mpiplot currently only supports meshes of topological dimension 2, got {mesh.topology().dim()}")
    if cell_kind not in ("triangle", "quadrilateral"):
        raise NotImplementedError(f"Expected 'triangle' or 'quadrilateral' cells in mesh, got '{cell_kind}'")

    element = V.ufl_element()
    family = str(element.family())
    degree = element.degree()
    if degree not in (0, 1, 2, 3) or family not in ("Lagrange",
                                                    "Discontinuous Lagrange",
                                                    "Q",
                                                    "DQ"):
        raise ValueError(f"Expected `u` to use a P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, or DQ3 element, got '{element.family()}' with degree {element.degree()}")

    # https://fenicsproject.discourse.group/t/gather-function-in-parallel-error/1114

    # # global DOF distribution between the MPI processes
    # d = V.dofmap().dofs()  # local, each process gets its own values
    # print(my_rank, min(d), max(d))

    if prep:
        V, polys, tris, subspace_dofs = prep
    else:
        V, polys, tris, subspace_dofs = mpiplot_prepare(u)

    # Make a complete copy of the DOF vector onto the root process.
    v_vec = u.vector().gather_on_zero()
    n_global_dofs = V.dim()

    # # make a complete copy of the DOF vector u_vec to all MPI processes
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self)  # local vector (local to each MPI process)
    # u_vec.gather(v_vec, np.array(range(V.dim()), "intc"))  # in_vec.gather(out_vec, indices); really "allgather"
    # dm = np.array(V.dofmap().dofs())
    # print(f"Process {my_rank}: local #DOFs {len(dm)} (min {min(dm)}, max {max(dm)}) out of global {V.dim()}")

    # # make a copy of the local part (in each MPI process) of u_vec only
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self, u_vec.local_size())
    # u_vec.gather(v_vec, V.dofmap().dofs())  # in_vec.gather(out_vec, indices)

    theplot = None
    if dolfin.MPI.comm_world.rank == 0:
        # The global DOF vector always refers to the complete function space.
        # If `V` is a subspace (vector/tensor field component), take only the
        # DOFs that belong to `V`. (For a true scalar space `V`, this is a no-op.)
        v_vec = v_vec[subspace_dofs]

        assert len(tris.x) == n_global_dofs  # each global DOF has coordinates
        assert len(v_vec) == n_global_dofs  # we have a data value at each DOF
        theplot = plt.tricontourf(tris, v_vec, levels=32, **kwargs)

        # # Alternative visualization style.
        # theplot = plt.tripcolor(tris, v_vec, shading="gouraud", **kwargs)
        # theplot = plt.tripcolor(tris, v_vec, shading="flat", **kwargs)

        # # Another alternative visualization style.
        # # https://matplotlib.org/stable/gallery/mplot3d/trisurf3d.html
        # ax = plt.figure().add_subplot(projection="3d")
        # theplot = ax.plot_trisurf(xs, ys, v_vec)

    if show_mesh:
        mpiplot_mesh(V,
                     show_partitioning=show_partitioning,
                     _polys=polys)

    return theplot


def mpiplot_mesh(V: dolfin.FunctionSpace, *,
                 main_color: str = "#80808040",
                 aux_color: str = "#80808020",
                 show_aux: bool = True,
                 show_partitioning: bool = False,
                 _polys=None) -> typing.Optional[typing.Any]:
    """Plot the mesh of a `FunctionSpace`.

    2D meshes only.

    Like `dolfin.plot(mesh)`, but plots the whole mesh in the root process.
    Also, is able to show the P1 vis edges (generated by `extrafeathers`)
    if `V` is a P2 or P3 `FunctionSpace`.

    `main_color`: "#RRGGBBAA", element edges.
    `aux_color`: "#RRGGBBAA", internal edges for P1 vis refinements.
                 Used only if `V` is a P2 or P3 function space.
    `show_aux`: Whether to plot the P1 vis refinement edges if present.
    `show_partitioning`: If `True`, color-code the mesh parts for different
                         MPI ranks. You can use `matplotlib.pyplot.legend`
                         to show which is which.
    `kwargs`: passed through to `matplotlib.pyplot.triplot`.

    `_polys` allows skipping the expensive auto-generation of a
    Matplotlib `PolyCollection` of the mesh edges, in case you already
     happen to have one. It is only used when `show_partitioning=False`.
    `mpiplot` uses this internally to share its `prep`. If you want to
    generate a `polys` yourself, see `as_mpl_triangulation`.

    If `show_partitioning=False`:
        In the root process (MPI rank 0), returns the `PolyCollection` object
        for the element edges.

        In other processes, returns `None`.

    If `show_partitioning=True`:
        Returns `None` in all processes.
    """
    if dolfin.MPI.comm_world.rank == 0:
        ax = plt.gca()

    # TODO: eliminate the almost-identical code
    if show_partitioning:  # color-code MPI partitions
        my_polys, ignored_triangulation = as_mpl_triangulation(V, mpi_global=False, refine=True)
        all_polys = dolfin.MPI.comm_world.gather(my_polys, root=0)
        if show_aux or V.ufl_element().degree() <= 1:
            if dolfin.MPI.comm_world.rank == 0:
                all_edges_colors = colors20 if V.ufl_element().degree() > 1 else colors40
                all_edges_width = 1.0 if V.ufl_element().degree() > 1 else 2.0
                for k, polys in enumerate(all_polys):
                    if not polys:
                        continue
                    polys.set_linewidth(all_edges_width)
                    polys.set_facecolor('none')
                    polys.set_edgecolor(all_edges_colors[k % len(all_edges_colors)])
                    ax.add_collection(polys)
        if V.ufl_element().degree() > 1:
            # element edges for higher degrees
            my_polys, ignored_triangulation = as_mpl_triangulation(V, mpi_global=False, refine=False)
            all_polys = dolfin.MPI.comm_world.gather(my_polys, root=0)
            if dolfin.MPI.comm_world.rank == 0:
                for k, polys in enumerate(all_polys):
                    if not polys:
                        continue
                    polys.set_linewidth(2.0)
                    polys.set_facecolor('none')
                    polys.set_edgecolor(all_edges_colors[k % len(colors40)])
                    ax.add_collection(polys)
        # Each legend entry from `triplot` is doubled for some reason,
        # so plot a dummy point (at NaN so it won't be drawn) with
        # each of the line colors and label them.
        if dolfin.MPI.comm_world.rank == 0:
            for mpi_rank in range(dolfin.MPI.comm_world.size):
                plt.plot([np.nan], [np.nan], color=colors40[mpi_rank % len(colors40)],
                         label=f"MPI rank {mpi_rank}")
        return

    # single color for all MPI partitions
    if not _polys:  # TODO: doesn't interact with `show_partitioning`
        polys, ignored_triangulation = as_mpl_triangulation(V, refine=True)
    main_plot = None
    if show_aux or V.ufl_element().degree() <= 1:
        if dolfin.MPI.comm_world.rank == 0:
            all_edges_color = aux_color if V.ufl_element().degree() > 1 else main_color
            all_edges_width = 1.0 if V.ufl_element().degree() > 1 else 2.0
            polys.set_linewidth(all_edges_width)
            polys.set_facecolor('none')
            polys.set_edgecolor(all_edges_color)
            ax.add_collection(polys)
            main_plot = polys
    if V.ufl_element().degree() > 1:
        # element edges for higher degrees
        polys, ignored_triangulation = as_mpl_triangulation(V, refine=False)
        if dolfin.MPI.comm_world.rank == 0:
            polys.set_facecolor('none')
            polys.set_edgecolor(main_color)
            polys.set_linewidth(2.0)
            ax.add_collection(polys)
            main_plot = polys
    return main_plot


def plot_facet_meshfunction(f: dolfin.MeshFunction,
                            names: typing.Optional[IntEnum] = None,
                            invalid_values: typing.Optional[typing.List[int]] = None) -> None:
    """Plot a `size_t` meshfunction defined on facets of a 2D mesh.

    Useful for checking whether boundaries have been tagged as expected.

    `dolfin.plot` should be preferred, but as of FEniCS 2019, it does not support
    plotting a mesh function defined on facets.

    Colors follow `matplotlib`'s default color cycle, with the tag value 0 mapped
    to the zeroth color.

    No MPI support - for use in serial mode only.

    `f`: Mesh function of type `size_t` on facets of a mesh. Any facet for which `f` has
         a nonzero value will be plotted, and colored according to the value of `f`.
         The colors follow the default color cycle of Matplotlib.

    `names`: If provided, names for the integer values are looked up in this `IntEnum`,
             and the lines are labeled (so that `matplotlib.pyplot.legend` can then be
             used to see which is which).

             Any value of the `MeshFunction` that does not have a corresponding entry
             in `names` is ignored (for example, internal facets inside the domain).

             Thus, only facets whose tags are *whitelisted* by presence in `names` will be plotted.
             They will be labeled (for `legend`) as e.g. "INLET (ID#1)" where "INLET" is a name
             from `names`, and `1` is the corresponding tag value.

    `invalid_values`: Alternative for `names`.

                     If provided, these tag values will be ignored. Useful values:
                         [0] for a manually generated `MeshFunction`, and
                         [2**64 - 1] for Gmsh import via `meshio`.

                     Thus, all facets whose tags are *not blacklisted* by presence in `invalid_values`
                     will be plotted. They will be labeled (for `legend`) as "<boundary> (ID#X)",
                     where "X" is the tag value.

                     If `names` is provided, it takes precedence.

    No return value.
    """
    mesh = f.mesh()
    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"This function only supports meshes of topological dimension 2, got {mesh.topology().dim()}")

    # Simplifying assumption: in geometric dimension 2, we can just discard the third coordinate of the vertices.
    if mesh.geometric_dimension() != 2:
        raise NotImplementedError(f"This function only supports meshes of geometric dimension 2, got {mesh.geometric_dimension()}")

    if f.dim() != 1:
        raise NotImplementedError(f"This function only supports mesh functions on facets (dimension 1); got a function of dimension {f.dim()}")
    if dolfin.MPI.comm_world.size > 1:
        # TODO: add MPI support.
        # Like the MPI plotter above, we should gather all data to the root process.
        # Not that important to implement, though, because mesh generation and import
        # (visualizing which is the primary use case for this function) is often done in serial mode.
        raise NotImplementedError("Facet meshfunction plotting currently only supported in serial mode.")

    if names:
        tag_to_name = {item.value: item.name for item in names}

    def empty_list() -> typing.List:
        return []
    plot_data = defaultdict(empty_list)
    for facet in dolfin.facets(mesh):
        tag = f[facet]
        ignore_tag = (names and tag not in tag_to_name) or (invalid_values is not None and tag in invalid_values)
        if not ignore_tag:
            vtxs = [vtx.point().array()[:2] for vtx in dolfin.vertices(facet)]  # [[x1, y1], [x2, y2]]
            plot_data[tag].append(vtxs)
            # Insert a NaN entry to force matplotlib to draw each facet separately,
            # instead of connecting them. (They are not in any useful order, and in general,
            # facets with the same tag need not form a connected line.)
            # https://stackoverflow.com/questions/21352580/matplotlib-plotting-numerous-disconnected-line-segments-with-different-colors
            plot_data[tag].append(np.array([[np.nan, np.nan]]))
    plot_data = {tag: np.concatenate(vtxss) for tag, vtxss in sorted(plot_data.items(), key=lambda item: item[0])}

    for tag, vtxs in plot_data.items():
        label = f"{tag_to_name[tag]} (ID#{tag})" if names else f"<boundary> (ID#{tag})"
        plt.plot(vtxs[:, 0], vtxs[:, 1], color=colors[tag % len(colors)], label=label)
