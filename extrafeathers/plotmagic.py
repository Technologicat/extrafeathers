# -*- coding: utf-8; -*-
"""Plotting utilities for FEniCS, using `matplotlib` as the backend.

We provide some "extra batteries" (i.e. features oddly missing from FEniCS itself)
for some common plotting tasks in 2D solvers:

- `mpiplot` allows a solver on a triangle mesh to plot the *whole* solution
  in the root process while running in MPI mode. This is often useful for
  debugging and visualizing simulation progress, especially for light MPI jobs
  that run locally on a laptop.

- `plot_facet_meshfunction` does exactly as it says on the tin. This is often
  useful for debugging and visualization when generating and importing meshes;
  it allows to check whether the boundaries have been tagged as expected.
"""

__all__ = ["pause",
           "as_mpl_triangulation",
           "mpiplot_prepare", "mpiplot", "mpiplot_mesh",
           "plot_facet_meshfunction"]

from collections import defaultdict
from enum import IntEnum
from itertools import chain
import typing

from unpythonic.env import env

import numpy as np
import matplotlib as mpl
import matplotlib.tri as mtri
import matplotlib.collections as mcoll
import matplotlib.pyplot as plt

import dolfin

from . import common
from . import meshmagic


# Use `matplotlib`'s default color sequence.
# https://matplotlib.org/stable/gallery/color/named_colors.html
# https://matplotlib.org/stable/tutorials/intermediate/color_cycle.html
colors = [item["color"] for item in mpl.rcParams["axes.prop_cycle"]]

# Mix translucent versions. `colors` must be in "#rrggbb" format for this to work.
def _colors_with_alpha(aa):
    return [f"{color}{aa}" for color in colors]
colors20 = _colors_with_alpha("20")
colors40 = _colors_with_alpha("40")


def pause(interval: float) -> None:
    """Redraw the current Matplotlib figure **without stealing focus**.

    **IMPORTANT**:

    Works after `plt.show()` has been called at least once.

    **Background**:

    Matplotlib (3.3.3) has a habit of popping the figure window to top when it
    is updated using show() or pause(), which effectively prevents using the
    machine for anything else while a simulation is in progress.

    On some systems, it helps to force Matplotlib to use the "Qt5Agg" backend:
        https://stackoverflow.com/questions/61397176/how-to-keep-matplotlib-from-stealing-focus

    but on some others (Linux Mint 20.1) also that backend steals focus.

    One option is to use a `FuncAnimation`, but it has a different API from
    just plotting regularly, and it is not applicable in all cases.

    So, we provide this a custom non-focus-stealing pause function hack,
    based on the StackOverflow answer by user @ImportanceOfBeingErnest:
        https://stackoverflow.com/a/45734500
    """
    backend = plt.rcParams['backend']
    if backend in mpl.rcsetup.interactive_bk:
        figManager = mpl._pylab_helpers.Gcf.get_active()
        if figManager is not None:
            canvas = figManager.canvas
            if canvas.figure.stale:
                canvas.draw_idle()
            canvas.start_event_loop(interval)


def as_mpl_triangulation(V: dolfin.FunctionSpace, *,
                         mpi_global: bool = True,
                         refine: bool = False) -> env:
    """Represent the mesh of a `FunctionSpace` in Matplotlib format.

    2D meshes only.

    `V`: a 2D scalar function space
         - `.sub(j)` of a vector or tensor function space is fine.
         - P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, DQ3 elements supported.

    `mpi_global`: If `True`, represent the whole mesh.

                  If `False`, represent the MPI-local mesh part. If this MPI process
                  has no cells, the return value is `None`.

    `refine`: If `True`, and `V` has degree higher than 1 (i.e. 2 or 3),
              represent the linear visualization cells (generated by `extrafeathers`).

              If `False`, represent the original cells. DOFs on element edges and
              in the element interior will be ignored; only vertices matter.

    Return value is an `unpythonic.env.env`, where the most important attributes are:

      - `polys` is a `matplotlib.collections.PolyCollection`.

        The cell type is the same as for the original mesh; quadrilateral meshes
        produce quadrilateral `polys`.

        Can be used to plot the edges (to adjust color, use `polys.set_edgecolor(c)`).
        Use `ax.add_collection(polys)` to add `polys` to an axes to actually show it.
        If you haven't explicitly created an axes object, use `ax = plt.gca()`.

      - `tris` is a `matplotlib.triangulation.Triangulation`.

        Can be used for function visualization using `tricontourf` and `tripcolor`.
        If needed, the triangulation itself can be visualized using `triplot`.

        **Quadrilateral meshes**:

        Because Matplotlib does not support unstructured quadrilateral meshes,
        we convert any quadrilateral mesh into a crossed-diagonal triangulation.
        This has 4× as many cells and asymptotically 2× as many DOFs as the original.

        The added global DOFs (cell centers) are tacked on to the end of the global
        DOF numbering, one per cell, in the same order as `all_cells` or `my_cells`
        extracts the cells.

        If `refine=True`, the triangle conversion is applied to the refined mesh.
        Hence e.g. a Q3 mesh will produce a triangulation with 36× as many triangles
        as the original quads (9× from Q3->Q1 and then a further 4× from Q1->P1).
        In the conversion, each linear visualization quad will get its own additional
        DOF at the center of the *visualization quad*.

        If `refine=False`, the triangle conversion is applied to the original mesh.
        Each original quad will get just one additional DOF at the cell center.
        Only the vertex DOFs will matter for interpolation.

        Note that when using the triangulation to interpolate a FEM function on
        quadrilaterals, you will need to generate the additional DOF values, and
        then concatenate those to the (subspace-relevant part of the) original
        DOF vector. `mpiplot` does this automatically.

    The return value remains valid for any function on the same space `V` and the
    same mesh. (Moving the mesh nodes invalidates it. Not checked; be careful.)
    """
    cell_kind = str(V.ufl_element().cell())
    if cell_kind not in ("triangle", "quadrilateral"):
        raise ValueError(f"Expected `V` to be defined on a triangle or quadrilateral mesh; got '{cell_kind}'.")

    # Before proceeding, renumber the DOFs into a contiguous zero-based range.
    # This numbering will correspond to the subspace-relevant slice of the global DOF vector.
    #
    # The fully general case is when `V` is on a `MixedElement` with several
    # vector/tensor fields, and the quantity of interest lives on `V.sub(j).sub(k)`
    # (field `j`, component `k`).
    try:
        V = V.collapse()
    except RuntimeError:  # not a subspace
        pass

    # TODO: Support DP0 (a.k.a. dG0) elements. We need to construct a degree-1 space
    # TODO: to get the element edges.

    # TODO: Support S and DS element families. These need adding extra DOFs during
    # TODO: the vis refinement; though S2 specifically could be supported alternatively
    # TODO: by just adding one DOF at the cell center and then converting to triangles,
    # TODO: to produce a union jack geometry:
    # TODO:     3-5-4
    # TODO:     |\|/|
    # TODO:     6-X-7
    # TODO:     |/|\|
    # TODO:     0-2-1
    # TODO:      S2

    # The cells for the MPI-local mesh part use the global DOF numbers, but refer
    # also to unowned nodes. Thus we must get a copy of the full global DOF and
    # coordinate data even if we want to construct just an MPI-local mesh part.
    cells, all_nodes = meshmagic.all_cells(V, matplotlibize=True, refine=refine)
    if not mpi_global:
        cells, _ = meshmagic.my_cells(V, matplotlibize=True, refine=refine)

    if not len(cells):
        return None

    # Extract the element edges.
    if cell_kind == "triangle":
        # For p > 1 triangles in FEniCS, the vertices are the first DOFs in each cell,
        # hence the cat smiley.
        vertices = [[all_nodes[dof] for dof in cell[:3]] for cell in cells]
    else:  # cell_kind == "quadrilateral":
        # For quads, Matplotlib expects a walk around the perimeter.
        vertices = [[all_nodes[dof] for dof in cell] for cell in cells]
        if refine:  # FEniCS Q1 -> Matplotlib Q1
            # Cells have been refined to degree 1 vis cells, so treat them as Q1.
            vertices = [[v[0], v[1], v[3], v[2]] for v in vertices]
        else:
            degree = V.ufl_element().degree()
            if degree == 1:  # FEniCS Q1 -> Matplotlib Q1
                # 2---3
                # |   |
                # |   |
                # |   |
                # 0---1
                #  Q1
                vertices = [[v[0], v[1], v[3], v[2]] for v in vertices]
            elif degree == 2:  # FEniCS Q2 -> Matplotlib Q1
                # 3-5-4
                # |   |
                # 6 8 7
                # |   |
                # 0-2-1
                #  Q2
                vertices = [[v[0], v[1], v[4], v[3]] for v in vertices]
            elif degree == 3:  # FEniCS Q3 -> Matplotlib Q1
                #  4--6--7--5
                #  |        |
                # 12 14 15 13
                #  |        |
                #  8 10 11  9
                #  |        |
                #  0--2--3--1
                #      Q3
                vertices = [[v[0], v[1], v[5], v[4]] for v in vertices]
            else:
                raise NotImplementedError(f"Expected degree 1, 2 or 3; got {degree}")
    prep = env()
    prep.polys = mcoll.PolyCollection(vertices)

    # Degree 1 or higher function visualization needs a triangulation for
    # `tricontourf`, `tripcolor`.
    if cell_kind == "triangle":
        triangles, nodes = cells, all_nodes

        # Although we collapsed `V`, the DOFs we got are not necessarily in a
        # zero-based consecutive range, because:
        #
        #  - If `mpi_global=False`, each process gets just some of the global DOFs of `V`.
        #    Hence only one of the ranges (the one at MPI rank 0) begins at zero.
        #
        #  - `quad_to_tri` (in the quadrilateral case further below) adds new DOFs that are
        #    globally unique across MPI processes. This splits the range of DOFs in each
        #    process into two subranges (original and added), each of which is consecutive,
        #    but with a gap between them.
        #
        # The triangulation needs a zero-based consecutive range for plotting, so we collapse now.
        triangles, nodes = meshmagic.collapse_node_numbering(triangles, nodes)
        dofs, nodes_array = meshmagic.nodes_to_array(nodes)
        prep.tris = mtri.Triangulation(nodes_array[:, 0], nodes_array[:, 1],
                                       triangles=triangles[:, :3])  # not quite te.tris
        assert len(prep.tris.x) == V.dim()  # each global DOF has coordinates
    else:  # cell_kind == "quadrilateral":
        # For plotting on quadrilateral meshes, we must bring the function onto `tris`.
        #
        # Quad mesh support is extremely incomplete and buggy in the original DOLFIN (even a single
        # quad cell may be "not orderable"). DOLFINx should work, but we don't support that yet.
        #
        # So with the old DOLFIN, we must never attempt to mesh-edit a quad mesh. Instead, we do
        # everything manually on the extrafeathers/Matplotlib side.
        #   https://bitbucket.org/fenics-project/dolfin/issues/997/quad-hex-meshes-need-ordering-check
        #   https://bitbucket.org/fenics-project/dolfin/issues/1089/quadrilateral-mesh-reordering-error

        # To map the function values onto the triangulation, we need vertex and cell center DOFs
        # for the **visualization** cells (see diagram below):
        #
        #   - If `refine=True`, the vis cells are the refined Q1 cells.
        #   - If `refine=False`, the vis cells are the original cells; we need the Q1 part.
        #
        # We want to bilinearly interpolate the function on the triangulation. Thus the cell center
        # DOF must be generated and filled in by `plotmagic`. Although in the case of Q2, the original
        # cell does have a midpoint DOF, it is an independent DOF, in general not consistent with the
        # bilinear interpolant of the vertex DOFs (which is what we need for the interpolation).
        #
        #   Original       Refine off     Refine on
        #                  Polycollection
        #
        #   +---+---+      +-------+      +---+---+
        #   |       |      |       |      |   |   |
        #   |       |      |       |      |   |   |
        #   |       |      |       |      |   |   |
        #   +   +   + ---> |       |  OR  +---+---+
        #   |       |      |       |      |   |   |
        #   |       |      |       |      |   |   |
        #   |       |      |       |      |   |   |
        #   +---+---+      +-------+      +---+---+
        #       Q2             Q1            4×Q1
        #
        #                      |             |
        #                      V             V
        #
        #                  +-------+      +---+---+
        #                  |\     /|      |\ /|\ /|
        #                  | \   / |      | X | X |
        #                  |  \ /  |      |/ \|/ \|
        #                  |   X   |      +---+---+
        #                  |  / \  |      |\ /|\ /|
        #                  | /   \ |      | X | X |
        #                  |/     \|      |/ \|/ \|
        #                  +-------+      +---+---+
        #                     4×P1          16×P1
        #
        #                  Triangulation
        #
        # In the diagram, `+` marks an original DOF, and `X` marks an extra DOF created by `quad_to_tri`,
        # which we insert to emulate bilinear interpolation on visualization quads, while using triangles.

        # Convert vis quads to triangles, collapse result, build triangulation.
        cellstri, nodestri = meshmagic.quad_to_tri(cells, all_nodes, mpi_global)
        cellstri, nodestri = meshmagic.collapse_node_numbering(cellstri, nodestri)
        dofstri, nodestri_array = meshmagic.nodes_to_array(nodestri)
        prep.tris = mtri.Triangulation(nodestri_array[:, 0], nodestri_array[:, 1], triangles=cellstri[:, :3])

        # Get vis cell vertices (ignoring edge and interior DOFs of the vis cells, if they have any)
        # Enabling `refine` has higher priority than `vertices_only`, so we can always specify both.
        cellsvtx, nodesvtx = meshmagic.all_cells(V, matplotlibize=True, refine=refine, vertices_only=True)
        if not mpi_global:
            cellsvtx, _ = meshmagic.my_cells(V, matplotlibize=True, refine=refine, vertices_only=True)
        prep.cellsvtx = cellsvtx
        prep.nodesvtx = nodesvtx

        # Map vis quad vertices to the quad_to_tri representation
        #
        # Usage reminder:
        #     WtoV, VtoW = _map_coincident(V, ..., W, ...)
        # Due to the containment assumption in the algorithm, the output of `quad_to_tri` should be
        # sent in as `W`.
        #
        # Here `W` is continuous across element edges iff `V` is (i.e. the conversion is Q->P, DQ->DP).
        family = V.ufl_element().family()
        iscontinuous = (family == "Q")
        tritovtx, vtxtotri = meshmagic._map_coincident(cellsvtx, nodesvtx, iscontinuous,
                                                       cellstri, nodestri, iscontinuous)
        tritovtx = common.prune(tritovtx)
        assert isinstance(next(iter(tritovtx.values())), (int, np.int64, np.uint64))  # should always be a single-valued mapping
        vtxtotri = common.prune(vtxtotri)
        assert isinstance(next(iter(vtxtotri.values())), (int, np.int64, np.uint64))  # should always be a single-valued mapping
        prep.tritovtx = tritovtx
        prep.vtxtotri = vtxtotri

        # Convert to index arrays for fast (NumPy vectorized) assignments
        def kvarrays(d):
            karray = np.array(list(d.keys()), dtype=np.uint64)
            varray = np.array(list(d.values()), dtype=np.uint64)
            return karray, varray
        tridofs_vtx, qdofs_vtx = kvarrays(tritovtx)
        prep.tridofs_vtx = tridofs_vtx
        prep.qdofs_vtx = qdofs_vtx

        # Get vis cell midpoints
        def cell_midpoints(cells, nodes):  # NOTE: averages all DOF coordinates; ideal for degree-1 cells
            midpoints = {}
            for cell_idx, cell in enumerate(cells):
                vtxs = np.array([nodes[dof] for dof in cell])
                midpoints[cell_idx] = np.sum(vtxs, axis=0) / len(vtxs)
            return midpoints
        # Note we do not need the original cell numbers even in MPI mode (where we could be dealing with just
        # an MPI-local mesh part), because we will generate the function values manually by averaging the
        # vertex DOFs - which are listed *using 0-based contiguous cell numbering* in `cellsvtx` (row number
        # of the array is the 0-based cell number).
        #
        # The vertex DOFs themselves are referred to using the original collapsed DOF numbering, so that the
        # subspace-relevant slice of the global DOF vector (for function values) can be used as-is.
        nodesmid = cell_midpoints(cellsvtx, nodesvtx)
        cellsmid = [[k] for k in range(len(nodesmid))]
        prep.nodesmid = nodesmid
        prep.cellsmid = cellsmid

        # Map vis quad centers (essentially, cell index) to the extra DOFs of the quad_to_tri representation
        #
        # We set `continuousV=True`, although this `V` is a discrete collection of cell midpoint values.
        # The important point is that there is just one unique DOF at the cell center (instead of several
        # DOFs belonging to different global elements), so we may treat it using the matching algorithm
        # designed for continuous spaces (which have the same property; each DOF is at a unique location).
        tritomid, midtotri = meshmagic._map_coincident(cellsmid, nodesmid, True,  # continuous
                                                       cellstri, nodestri, iscontinuous)
        tritomid = common.prune(tritomid)
        assert isinstance(next(iter(tritomid.values())), (int, np.int64, np.uint64))  # should always be a single-valued mapping
        midtotri = common.prune(midtotri)
        assert isinstance(next(iter(midtotri.values())), (int, np.int64, np.uint64))  # should always be a single-valued mapping
        assert set(chain(midtotri.values(), vtxtotri.values())) == set(range(len(nodestri)))  # all triangulation DOFs are mapped to, and have contiguous zero-based numbering
        prep.tritomid = tritomid
        prep.midtotri = midtotri

        # # "original collapsed DOF numbering" = index in subspace-relevant slice of global DOF vector
        # def s(d):
        #     return dict(sorted(d.items(), key=lambda item: item[0]))
        # print(s(nodesvtx))  # vis quad vertices in original collapsed DOF numbering
        # print(cellsvtx)  # vis quads in original collapsed DOF numbering
        # print(s(midtotri))  # vis quad cell index (row of `cellsvtx`) -> (added) DOF on triangulation
        # print(s(tritovtx))  # (original) DOF on triangulation -> original collapsed DOF number
        # print(len(nodestri))  # number of DOFs on triangulation

        # Pre-allocate global DOF vector for function values on the triangulation
        prep.vec_vis = np.empty(len(nodestri))

    return prep


def mpiplot_prepare(u: typing.Union[dolfin.Function, dolfin.Expression]) -> env:
    """Optional performance optimization for `mpiplot`.

    Allows re-using the mesh and dofmap analysis across several plots.

    `u`: `dolfin.Function`; a 2D scalar FEM field
         - `.sub(j)` of a vector or tensor field is fine.
         - P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, DQ3 elements supported.

    See `as_mpl_triangulation`, which does most of the work.

    If `V = u.function_space()` is a subspace (vector/tensor field component),
    this function determines which global DOFs belong to `V`.

    The return value is an `unpythonic.env.env`. Basically, it is the return value
    from `as_mpl_triangulation`, with the dofmap analysis added.

      - The return value can be passed into `mpiplot` as the `prep` argument.

      - The `prep.polys` attribute can also be passed into `mpiplot_mesh` as the
        `_polys` argument.

    The return value remains valid for any function on the same space `V` and the
    same mesh. (Moving the mesh nodes invalidates it. Not checked; be careful.)
    """
    V = u.function_space()
    mesh = V.mesh()
    cell_kind = mesh.cell_name()

    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"mpiplot_prepare currently only supports meshes of topological dimension 2, got {mesh.topology().dim()}")
    if cell_kind not in ("triangle", "quadrilateral"):
        raise NotImplementedError(f"Expected 'triangle' or 'quadrilateral' cells in mesh, got '{cell_kind}'")

    element = V.ufl_element()
    family = str(element.family())
    degree = element.degree()
    if degree not in (0, 1, 2, 3) or family not in ("Lagrange", "P",
                                                    "Discontinuous Lagrange", "DP",
                                                    "Q",
                                                    "DQ"):
        raise ValueError(f"Expected `u` to use a P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, or DQ3 element, got '{element.family()}' with degree {element.degree()}")

    # The global DOF vector always refers to the complete function space.
    # If `V` is a subspace (vector/tensor field component), the DOF vector
    # will include also those DOFs that are not part of `V`. Determine the
    # DOFs that belong to `V`.
    dofmaps = dolfin.MPI.comm_world.allgather(V.dofmap().dofs())

    # CAUTION: `all_cells`, used by `as_mpl_triangulation`,
    # sorts the nodes by global DOF number; must match the ordering.
    # FEniCS keeps a contiguous block of DOF numbers for each MPI process,
    # and they are kept sorted, so this is satisfied.
    subspace_dofs = np.sort(np.concatenate(dofmaps))

    prep = as_mpl_triangulation(V, refine=True)  # this converts to degree 1
    prep.V = V
    prep.subspace_dofs = subspace_dofs
    return prep


# TODO: not sure what exactly `matplotlib.pyplot.tricontourf` returns or what the type spec for it should be.
# The point of the Optional return value is to make it explicit it's something-or-None.
def mpiplot(u: typing.Union[dolfin.Function, dolfin.Expression], *,
            show_mesh: bool = False,
            show_partitioning: bool = False,
            prep: typing.Optional[env] = None,
            **kwargs: typing.Any) -> typing.Optional[typing.Any]:
    """Like `dolfin.plot`, but plots the whole field in the root process (MPI rank 0).

    `u`: `dolfin.Function`; a 2D scalar FEM field
         - `.sub(j)` of a vector or tensor field is fine.
         - P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, DQ3 elements supported.

    `show_mesh`: if `True`, show the element edges. If `u` is degree 2 or 3, show the
                 vis edges, too.

    `show_partitioning`: Used only if `show_mesh=True`.

                     If `True`, color-code the mesh parts for different MPI ranks.
                     Adds the meanings of the colors to the Matplotlib legend
                     automatically; see `matplotlib.pyplot.legend`.

    `prep`: optional performance optimization, see `mpiplot_prepare` to generate this.

            This is useful if you intend to plot many functions that live on the same
            function space (or the same function at many timesteps), because a static
            mesh and the DOF mapping only need to be analyzed once.

    `kwargs`: passed through to `matplotlib.pyplot.tricontourf`

    If `u` lives on degree 2 or 3 elements, each element is internally split into
    linear elements for visualization. Furthermore, quads are internally split into
    triangles (in a crossed-diagonal configuration) to interpolate the function for
    visualization.

    In the root process (MPI rank 0), returns the plot object.
    See the return value of `matplotlib.pyplot.tricontourf`.

    In other processes, returns `None`.
    """
    V = u.function_space()
    mesh = V.mesh()
    cell_kind = mesh.cell_name()

    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"mpiplot currently only supports meshes of topological dimension 2, got {mesh.topology().dim()}")
    if cell_kind not in ("triangle", "quadrilateral"):
        raise NotImplementedError(f"Expected 'triangle' or 'quadrilateral' cells in mesh, got '{cell_kind}'")

    element = V.ufl_element()
    family = str(element.family())
    degree = element.degree()
    if degree not in (0, 1, 2, 3) or family not in ("Lagrange", "P",
                                                    "Discontinuous Lagrange", "DP",
                                                    "Q",
                                                    "DQ"):
        raise ValueError(f"Expected `u` to use a P1, P2, P3, DP1, DP2, DP3, Q1, Q2, Q3, DQ1, DQ2, or DQ3 element, got '{element.family()}' with degree {element.degree()}")

    # https://fenicsproject.discourse.group/t/gather-function-in-parallel-error/1114

    # # global DOF distribution between the MPI processes
    # d = V.dofmap().dofs()  # local, each process gets its own values
    # print(my_rank, min(d), max(d))

    if not prep:
        prep = mpiplot_prepare(u)

    # Make a complete copy of the DOF vector onto the root process.
    v_vec = u.vector().gather_on_zero()
    n_global_dofs = V.dim()

    # # make a complete copy of the DOF vector u_vec to all MPI processes
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self)  # local vector (local to each MPI process)
    # u_vec.gather(v_vec, np.array(range(V.dim()), "intc"))  # in_vec.gather(out_vec, indices); really "allgather"
    # dm = np.array(V.dofmap().dofs())
    # print(f"Process {my_rank}: local #DOFs {len(dm)} (min {min(dm)}, max {max(dm)}) out of global {V.dim()}")

    # # make a copy of the local part (in each MPI process) of u_vec only
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self, u_vec.local_size())
    # u_vec.gather(v_vec, V.dofmap().dofs())  # in_vec.gather(out_vec, indices)

    theplot = None
    if dolfin.MPI.comm_world.rank == 0:
        # The global DOF vector always refers to the complete function space.
        # If `V` is a subspace (vector/tensor field component), take only the
        # DOFs that belong to `V`. (For a true scalar space `V`, this is a no-op.)
        v_vec = v_vec[prep.subspace_dofs]
        assert len(v_vec) == n_global_dofs  # we have a data value at each DOF of the relevant subspace

        if cell_kind == "triangle":
            vec_vis = v_vec
        else:  # cell_kind == "quadrilateral":
            vec_vis = prep.vec_vis

            # vertex values: take from (subspace-relevant slice of) original global DOF vector
            vec_vis[prep.tridofs_vtx] = v_vec[prep.qdofs_vtx]

            # cell midpoint values: emulate bilinear interpolation
            for cell_idx, cell in enumerate(prep.cellsvtx):
                tridof_center = prep.midtotri[cell_idx]
                qdofs_vtx = np.array(cell, dtype=np.uint64)  # vertex DOFs only (for bilerp)
                mean_value = np.sum(v_vec[qdofs_vtx]) / len(qdofs_vtx)
                vec_vis[tridof_center] = mean_value

        # TODO: Support DP0 (a.k.a. dG0) elements. Need to `tripcolor` with `shading='flat'`
        # TODO: since DP0 data is piecewise constant (one value per element).

        theplot = plt.tricontourf(prep.tris, vec_vis, levels=32, **kwargs)

        # # Alternative visualization style.
        # theplot = plt.tripcolor(prep.tris, vec_vis, shading="gouraud", **kwargs)
        # theplot = plt.tripcolor(prep.tris, vec_vis, shading="flat", **kwargs)

        # # Another alternative visualization style.
        # # https://matplotlib.org/stable/gallery/mplot3d/trisurf3d.html
        # ax = plt.figure().add_subplot(projection="3d")
        # theplot = ax.plot_trisurf(xs, ys, vec_vis)

    if show_mesh:
        mpiplot_mesh(V,
                     show_partitioning=show_partitioning,
                     _polys=prep.polys)

    return theplot


def mpiplot_mesh(V: dolfin.FunctionSpace, *,
                 main_color: str = "#80808040",
                 aux_color: str = "#80808020",
                 show_aux: bool = True,
                 show_partitioning: bool = False,
                 _polys=None) -> typing.Optional[typing.Any]:
    """Plot the mesh of a `FunctionSpace`.

    2D meshes only.

    Like `dolfin.plot(mesh)`, but plots the whole mesh in the root process.
    Also, is able to show the P1 vis edges (generated by `extrafeathers`)
    if `V` is a P2 or P3 `FunctionSpace`.

    `main_color`: "#RRGGBBAA", element edges.
    `aux_color`: "#RRGGBBAA", internal edges for P1 vis refinements.
                 Used only if `V` is a P2 or P3 function space.
    `show_aux`: Whether to plot the P1 vis refinement edges if present.
    `show_partitioning`: If `True`, color-code the mesh parts for different
                         MPI ranks. You can use `matplotlib.pyplot.legend`
                         to show which is which.
    `kwargs`: passed through to `matplotlib.pyplot.triplot`.

    `_polys` allows skipping the expensive auto-generation of a
    Matplotlib `PolyCollection` of the mesh edges, in case you already
     happen to have one. It is only used when `show_partitioning=False`.
    `mpiplot` uses this internally to share its `prep`. If you want to
    generate a `polys` yourself, see `as_mpl_triangulation`.

    If `show_partitioning=False`:
        In the root process (MPI rank 0), returns the `PolyCollection` object
        for the element edges.

        In other processes, returns `None`.

    If `show_partitioning=True`:
        Returns `None` in all processes.
    """
    if dolfin.MPI.comm_world.rank == 0:
        ax = plt.gca()

    # TODO: eliminate the almost-identical code
    if show_partitioning:  # color-code MPI partitions
        prep = as_mpl_triangulation(V, mpi_global=False, refine=True)
        my_polys = prep.polys
        all_polys = dolfin.MPI.comm_world.gather(my_polys, root=0)
        if show_aux or V.ufl_element().degree() <= 1:
            # all edges
            if dolfin.MPI.comm_world.rank == 0:
                all_edges_width = 1.0 if V.ufl_element().degree() > 1 else 2.0
                all_edges_colors = colors20 if V.ufl_element().degree() > 1 else colors40
                for k, polys in enumerate(all_polys):
                    if not polys:
                        continue
                    polys.set_linewidth(all_edges_width)
                    polys.set_edgecolor(all_edges_colors[k % len(all_edges_colors)])
                    polys.set_facecolor('none')
                    ax.add_collection(polys)
        if V.ufl_element().degree() > 1:
            # element edges for higher degrees
            prep = as_mpl_triangulation(V, mpi_global=False, refine=False)
            my_polys = prep.polys
            all_polys = dolfin.MPI.comm_world.gather(my_polys, root=0)
            if dolfin.MPI.comm_world.rank == 0:
                for k, polys in enumerate(all_polys):
                    if not polys:
                        continue
                    polys.set_linewidth(2.0)
                    polys.set_edgecolor(all_edges_colors[k % len(colors40)])
                    polys.set_facecolor('none')
                    ax.add_collection(polys)
        # Each legend entry from `triplot` is doubled for some reason,
        # so plot a dummy point (at NaN so it won't be drawn) with
        # each of the line colors and label them.
        if dolfin.MPI.comm_world.rank == 0:
            for mpi_rank in range(dolfin.MPI.comm_world.size):
                plt.plot([np.nan], [np.nan], color=colors40[mpi_rank % len(colors40)],
                         label=f"MPI rank {mpi_rank}")
        return

    # single color for all MPI partitions
    if _polys:  # TODO: doesn't interact with `show_partitioning`
        polys = _polys
    else:
        prep = as_mpl_triangulation(V, refine=True)
        polys = prep.polys
    main_plot = None
    if show_aux or V.ufl_element().degree() <= 1:
        # all edges
        if dolfin.MPI.comm_world.rank == 0:
            all_edges_width = 1.0 if V.ufl_element().degree() > 1 else 2.0
            all_edges_color = aux_color if V.ufl_element().degree() > 1 else main_color
            polys.set_linewidth(all_edges_width)
            polys.set_edgecolor(all_edges_color)
            polys.set_facecolor('none')
            ax.add_collection(polys)
            main_plot = polys
    if V.ufl_element().degree() > 1:
        # element edges for higher degrees
        prep = as_mpl_triangulation(V, refine=False)
        polys = prep.polys
        if dolfin.MPI.comm_world.rank == 0:
            polys.set_linewidth(2.0)
            polys.set_edgecolor(main_color)
            polys.set_facecolor('none')
            ax.add_collection(polys)
            main_plot = polys
    return main_plot


def plot_facet_meshfunction(f: dolfin.MeshFunction,
                            names: typing.Optional[IntEnum] = None,
                            invalid_values: typing.Optional[typing.List[int]] = None) -> None:
    """Plot a `size_t` meshfunction defined on facets of a 2D mesh.

    Useful for checking whether boundaries have been tagged as expected.

    `dolfin.plot` should be preferred, but as of FEniCS 2019, it does not support
    plotting a mesh function defined on facets.

    Colors follow `matplotlib`'s default color cycle, with the tag value 0 mapped
    to the zeroth color.

    No MPI support - for use in serial mode only.

    `f`: Mesh function of type `size_t` on facets of a mesh. Any facet for which `f` has
         a nonzero value will be plotted, and colored according to the value of `f`.
         The colors follow the default color cycle of Matplotlib.

    `names`: If provided, names for the integer values are looked up in this `IntEnum`,
             and the lines are labeled (so that `matplotlib.pyplot.legend` can then be
             used to see which is which).

             Any value of the `MeshFunction` that does not have a corresponding entry
             in `names` is ignored (for example, internal facets inside the domain).

             Thus, only facets whose tags are *whitelisted* by presence in `names` will be plotted.
             They will be labeled (for `legend`) as e.g. "INLET (ID#1)" where "INLET" is a name
             from `names`, and `1` is the corresponding tag value.

    `invalid_values`: Alternative for `names`.

                     If provided, these tag values will be ignored. Useful values:
                         [0] for a manually generated `MeshFunction`, and
                         [2**64 - 1] for Gmsh import via `meshio`.

                     Thus, all facets whose tags are *not blacklisted* by presence in `invalid_values`
                     will be plotted. They will be labeled (for `legend`) as "<boundary> (ID#X)",
                     where "X" is the tag value.

                     If `names` is provided, it takes precedence.

    No return value.
    """
    mesh = f.mesh()
    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"This function only supports meshes of topological dimension 2, got {mesh.topology().dim()}")

    # Simplifying assumption: in geometric dimension 2, we can just discard the third coordinate of the vertices.
    if mesh.geometric_dimension() != 2:
        raise NotImplementedError(f"This function only supports meshes of geometric dimension 2, got {mesh.geometric_dimension()}")

    if f.dim() != 1:
        raise NotImplementedError(f"This function only supports mesh functions on facets (dimension 1); got a function of dimension {f.dim()}")
    if dolfin.MPI.comm_world.size > 1:
        # TODO: add MPI support.
        # Like the MPI plotter above, we should gather all data to the root process.
        # Not that important to implement, though, because mesh generation and import
        # (visualizing which is the primary use case for this function) is often done in serial mode.
        raise NotImplementedError("Facet meshfunction plotting currently only supported in serial mode.")

    if names:
        tag_to_name = {item.value: item.name for item in names}

    def empty_list() -> typing.List:
        return []
    plot_data = defaultdict(empty_list)
    for facet in dolfin.facets(mesh):
        tag = f[facet]
        ignore_tag = (names and tag not in tag_to_name) or (invalid_values is not None and tag in invalid_values)
        if not ignore_tag:
            vtxs = [vtx.point().array()[:2] for vtx in dolfin.vertices(facet)]  # [[x1, y1], [x2, y2]]
            plot_data[tag].append(vtxs)
            # Insert a NaN entry to force matplotlib to draw each facet separately,
            # instead of connecting them. (They are not in any useful order, and in general,
            # facets with the same tag need not form a connected line.)
            # https://stackoverflow.com/questions/21352580/matplotlib-plotting-numerous-disconnected-line-segments-with-different-colors
            plot_data[tag].append(np.array([[np.nan, np.nan]]))
    plot_data = {tag: np.concatenate(vtxss) for tag, vtxss in sorted(plot_data.items(), key=lambda item: item[0])}

    for tag, vtxs in plot_data.items():
        label = f"{tag_to_name[tag]} (ID#{tag})" if names else f"<boundary> (ID#{tag})"
        plt.plot(vtxs[:, 0], vtxs[:, 1], color=colors[tag % len(colors)], label=label)
