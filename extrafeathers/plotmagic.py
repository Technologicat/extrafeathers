# -*- coding: utf-8; -*-
"""Plotting utilities for FEniCS, using `matplotlib` as the backend.

We provide some "extra batteries" (i.e. features oddly missing from FEniCS itself)
for some common plotting tasks in 2D solvers:

- `mpiplot` allows a solver on a triangle mesh to plot the *whole* solution
  in the root process while running in MPI mode. This is often useful for
  debugging and visualizing simulation progress, especially for light MPI jobs
  that run locally on a laptop.

- `plot_facet_meshfunction` does exactly as it says on the tin. This is often
  useful for debugging and visualization when generating and importing meshes;
  it allows to check whether the boundaries have been tagged as expected.
"""

__all__ = ["pause",
           "as_mpl_triangulation",
           "mpiplot", "mpiplot_mesh",
           "plot_facet_meshfunction"]

from collections import defaultdict
from enum import IntEnum
import typing

import numpy as np
import matplotlib as mpl
import matplotlib.tri as mtri
import matplotlib.pyplot as plt

import dolfin

from .meshmagic import all_cells, my_cells, nodes_to_array


# Use `matplotlib`'s default color sequence.
# https://matplotlib.org/stable/gallery/color/named_colors.html
# https://matplotlib.org/stable/tutorials/intermediate/color_cycle.html
colors = [item["color"] for item in mpl.rcParams["axes.prop_cycle"]]

# Mix translucent versions for plotting MPI partitioning.
# `colors` must be in "#rrggbb" format for this to work.
def _colors_with_alpha(aa):
    return [f"{color}{aa}" for color in colors]
colors20 = _colors_with_alpha("20")
colors40 = _colors_with_alpha("40")


def pause(interval: float) -> None:
    """Redraw the current Matplotlib figure **without stealing focus**.

    **IMPORTANT**:

    Works after `plt.show()` has been called at least once.

    **Background**:

    Matplotlib (3.3.3) has a habit of popping the figure window to top when it
    is updated using show() or pause(), which effectively prevents using the
    machine for anything else while a simulation is in progress.

    On some systems, it helps to force Matplotlib to use the "Qt5Agg" backend:
        https://stackoverflow.com/questions/61397176/how-to-keep-matplotlib-from-stealing-focus

    but on some others (Linux Mint 20.1) also that backend steals focus.

    One option is to use a `FuncAnimation`, but it has a different API from
    just plotting regularly, and it is not applicable in all cases.

    So, we provide this a custom non-focus-stealing pause function hack,
    based on the StackOverflow answer by user @ImportanceOfBeingErnest:
        https://stackoverflow.com/a/45734500

    """
    backend = plt.rcParams['backend']
    if backend in mpl.rcsetup.interactive_bk:
        figManager = mpl._pylab_helpers.Gcf.get_active()
        if figManager is not None:
            canvas = figManager.canvas
            if canvas.figure.stale:
                canvas.draw_idle()
            canvas.start_event_loop(interval)


def as_mpl_triangulation(V: dolfin.FunctionSpace, *,
                         mpi_global: bool = True,
                         refine: bool = False) -> mtri.Triangulation:
    """Represent the mesh of a `FunctionSpace` as a Matplotlib `Triangulation`.

    2D triangle meshes only.

    The `FunctionSpace` should be scalar. `.sub(j)` of a vector or tensor
    function space is fine.

    `mpi_global`: If `True`, get the whole mesh.
                  If `False`, get the MPI-local mesh part.
    `refine`: If `True`, get also the P1 vis edges (generated by
              `extrafeathers`)for P2 or P3 function spaces.
              If `False`, get only the element edges.
    """
    # The triangulation for the MPI-local mesh part uses the global DOF numbers
    # `dofs[k]`, but refers also to unowned nodes. Thus we must get a copy of
    # the full global DOF and coordinate data to be able to construct a mesh part.
    all_triangles, all_nodes_dict = all_cells(V, matplotlibize=True, refine=refine)
    dofs, nodes = nodes_to_array(all_nodes_dict)

    # Now get the relevant mesh part. We actually only need the triangles;
    # we can ignore the DOF/coordinate data, since we already have a full
    # copy (from the global scan).
    if mpi_global:
        triangles, ignored_nodes_dict = all_triangles, all_nodes_dict
    else:
        triangles, ignored_nodes_dict = my_cells(V, matplotlibize=True, refine=refine)

    # Map `triangles`; it has global DOF numbers `dofs[k]`, whereas we need just `k`
    # so that the numbering corresponds to the rows of `nodes`.
    #
    # Ignoring the mapping works as long as the data comes from a true scalar
    # `FunctionSpace`; then it's the identity mapping. But with subspace data
    # we need to do this.
    #
    # Note that to perform this mapping we always need a full copy of the global
    # DOF data, because MPI-local cells refer to unowned nodes, too. Thus the
    # MPI-local part is not enough.
    #
    # `dofs` is already sorted by global DOF number, by `nodes_to_array`
    dof_to_row = {dof: k for k, dof in enumerate(dofs)}
    new_triangles = [[dof_to_row[dof] for dof in triangle]
                     for triangle in triangles]
    new_triangles = np.array(new_triangles, dtype=np.int64)

    # Now we can construct the triangulation.
    # This relies on the fact that for p > 1, in FEniCS the vertices are the
    # first DOFs in each triangle.
    return mtri.Triangulation(nodes[:, 0], nodes[:, 1], triangles=new_triangles[:, :3])


# TODO: not sure what exactly `matplotlib.pyplot.tricontourf` returns or what the type spec for it should be.
# The point of the Optional return value is to make it explicit it's something-or-None.
def mpiplot(u: typing.Union[dolfin.Function, dolfin.Expression], *,
            show_mesh: bool = False,
            show_partitioning: bool = False,
            **kwargs: typing.Any) -> typing.Optional[typing.Any]:
    """Like `dolfin.plot`, but plots the whole field in the root process (MPI rank 0).

    `u`: `dolfin.Function`; a 2D scalar FEM field
         (`.sub(j)` of a vector or tensor field is fine)
    `show_mesh`: if `True`, show the element edges (and P1 vis edges too,
                 if `u` is a `P2` or `P3` function).
    `show_partitioning`: Used only if `show_mesh=True`.
                     If `True`, color-code the mesh parts for different MPI ranks.
                     You can use `matplotlib.pyplot.legend` to show which is which.
    `kwargs`: passed through to `matplotlib.pyplot.tricontourf`

    If `u` lives on P2 or P3 elements, each element will be internally split into
    P1 triangles for visualization.

    In the root process (MPI rank 0), returns the plot object.
    See the return value of `matplotlib.pyplot.tricontourf`.

    In other processes, returns `None`.
    """
    V = u.function_space()
    mesh = V.mesh()
    my_rank = dolfin.MPI.comm_world.rank

    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"mpiplot currently only supports meshes of topological dimension 2, got {mesh.topology().dim()}")

    # https://fenicsproject.discourse.group/t/gather-function-in-parallel-error/1114

    # # global DOF distribution between the MPI processes
    # d = V.dofmap().dofs()  # local, each process gets its own values
    # print(my_rank, min(d), max(d))

    # If not a supported element type, project to P1 elements
    # for easy reconstruction for visualization.
    if not (str(V.ufl_element().cell()) == "triangle" and
            V.ufl_element().degree() in (1, 2, 3)):
        V_vis = dolfin.FunctionSpace(mesh, "P", 1)
        u_vis = dolfin.project(u, V_vis)
    else:
        V_vis = V
        u_vis = u

    # Make a complete copy of the DOF vector onto the root process.
    v_vec = u_vis.vector().gather_on_zero()
    n_global_dofs = V_vis.dim()

    # # make a complete copy of the DOF vector u_vec to all MPI processes
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self)  # local vector (local to each MPI process)
    # u_vec.gather(v_vec, np.array(range(V.dim()), "intc"))  # in_vec.gather(out_vec, indices); really "allgather"
    # dm = np.array(V.dofmap().dofs())
    # print(f"Process {my_rank}: local #DOFs {len(dm)} (min {min(dm)}, max {max(dm)}) out of global {V.dim()}")

    # # make a copy of the local part (in each MPI process) of u_vec only
    # u_vec = u.vector()
    # v_vec = dolfin.Vector(dolfin.MPI.comm_self, u_vec.local_size())
    # u_vec.gather(v_vec, V.dofmap().dofs())  # in_vec.gather(out_vec, indices)

    # The global DOF vector always refers to the complete function space.
    # If `V` is a subspace (vector/tensor field component), the DOF vector
    # will include also those DOFs that are not part of `V`. Extract the
    # V DOFs.
    dofmaps = dolfin.MPI.comm_world.gather(V_vis.dofmap().dofs(), root=0)
    if my_rank == 0:
        # CAUTION: `all_cells`, used by `as_mpl_triangulation`,
        # sorts the nodes by global DOF number; match the ordering.
        subspace_dofs = np.sort(np.concatenate(dofmaps))
        v_vec = v_vec[subspace_dofs]

    theplot = None
    tri = as_mpl_triangulation(V_vis, refine=True)  # this converts P2/P3 -> P1
    if my_rank == 0:
        assert len(tri.x) == n_global_dofs  # each global DOF has coordinates
        assert len(v_vec) == n_global_dofs  # we have a data value at each DOF
        theplot = plt.tricontourf(tri, v_vec, levels=32, **kwargs)

        # # Alternative visualization style.
        # theplot = plt.tripcolor(tri, v_vec, shading="gouraud", **kwargs)

        # # Another alternative visualization style.
        # # https://matplotlib.org/stable/gallery/mplot3d/trisurf3d.html
        # ax = plt.figure().add_subplot(projection="3d")
        # theplot = ax.plot_trisurf(xs, ys, v_vec)

    if show_mesh:
        mpiplot_mesh(V_vis,
                     show_partitioning=show_partitioning,
                     _triangulation=tri)

    return theplot


def mpiplot_mesh(V: dolfin.FunctionSpace, *,
                 main_color: str = "#80808040",
                 aux_color: str = "#80808020",
                 show_aux: bool = True,
                 show_partitioning: bool = False,
                 _triangulation=None,
                 **kwargs) -> typing.Optional[typing.Any]:
    """Plot the mesh of a `FunctionSpace`.

    2D triangle meshes only.

    Like `dolfin.plot(mesh)`, but plots the whole mesh in the root process.
    Also, is able to show the P1 vis edges (generated by `extrafeathers`)
    if `V` is a P2 or P3 `FunctionSpace`.

    `main_color`: "#RRGGBBAA", element edges.
    `aux_color`: "#RRGGBBAA", internal edges for P1 vis refinements.
                 Used only if `V` is a P2 or P3 function space.
    `show_aux`: Whether to plot the P1 vis refinement edges if present.
    `show_partitioning`: If `True`, color-code the mesh parts for different
                         MPI ranks. You can use `matplotlib.pyplot.legend`
                         to show which is which.
    `kwargs`: passed through to `matplotlib.pyplot.triplot`.

    `_triangulation` allows skipping the expensive auto-generation of a
    Matplotlib triangulation of the mesh, in case you already happen to
    have one. It is only used when `show_partitioning=False`. `mpiplot`
    uses this to send in the triangulation it has built anyway (to be
    able to visualize the actual function). If you want to generate one
    yourself, see `as_mpl_triangulation`.

    If `show_partitioning=False`:
        In the root process (MPI rank 0), returns the plot object for the
        element edges. See the return value of `matplotlib.pyplot.triplot`.

        In other processes, returns `None`.

    If `show_partitioning=True`:
        Returns `None` in all processes.
    """
    # TODO: eliminate the almost-identical code
    if show_partitioning:  # color-code MPI partitions
        my_triangulation = as_mpl_triangulation(V, mpi_global=False, refine=True)
        all_triangulations = dolfin.MPI.comm_world.gather(my_triangulation, root=0)
        if show_aux or V.ufl_element().degree() <= 1:
            if dolfin.MPI.comm_world.rank == 0:
                all_edges_colors = colors20 if V.ufl_element().degree() > 1 else colors40
                for k, tri in enumerate(all_triangulations):
                    plt.triplot(tri, color=all_edges_colors[k % len(all_edges_colors)],
                                **kwargs)
        if V.ufl_element().degree() > 1:
            my_triangulation = as_mpl_triangulation(V, mpi_global=False, refine=False)
            all_triangulations = dolfin.MPI.comm_world.gather(my_triangulation, root=0)
            if dolfin.MPI.comm_world.rank == 0:
                for k, tri in enumerate(all_triangulations):
                    plt.triplot(tri, color=colors40[k % len(colors40)], **kwargs)
        # Each legend entry from `triplot` is doubled for some reason,
        # so plot a dummy point (at NaN so it won't be drawn) with
        # each of the line colors and label them.
        if dolfin.MPI.comm_world.rank == 0:
            for mpi_rank in range(dolfin.MPI.comm_world.size):
                plt.plot([np.nan], [np.nan], color=colors40[mpi_rank % len(colors40)],
                         label=f"MPI rank {mpi_rank}")
        return

    # single color for all MPI partitions
    if not _triangulation:  # TODO: doesn't interact with `show_partitioning`
        _triangulation = as_mpl_triangulation(V, refine=True)
    main_plot = None
    if show_aux or V.ufl_element().degree() <= 1:
        if dolfin.MPI.comm_world.rank == 0:
            all_edges_color = aux_color if V.ufl_element().degree() > 1 else main_color
            main_plot = plt.triplot(_triangulation, color=all_edges_color, **kwargs)
    if V.ufl_element().degree() > 1:
        element_edges = as_mpl_triangulation(V, refine=False)
        if dolfin.MPI.comm_world.rank == 0:
            main_plot = plt.triplot(element_edges, color=main_color, **kwargs)
    return main_plot


def plot_facet_meshfunction(f: dolfin.MeshFunction,
                            names: typing.Optional[IntEnum] = None,
                            invalid_values: typing.Optional[typing.List[int]] = None) -> None:
    """Plot a `size_t` meshfunction defined on facets of a 2D mesh.

    Useful for checking whether boundaries have been tagged as expected.

    `dolfin.plot` should be preferred, but as of FEniCS 2019, it does not support
    plotting a mesh function defined on facets.

    Colors follow `matplotlib`'s default color cycle, with the tag value 0 mapped
    to the zeroth color.

    No MPI support - for use in serial mode only.

    `f`: Mesh function of type `size_t` on facets of a mesh. Any facet for which `f` has
         a nonzero value will be plotted, and colored according to the value of `f`.
         The colors follow the default color cycle of Matplotlib.

    `names`: If provided, names for the integer values are looked up in this `IntEnum`,
             and the lines are labeled (so that `matplotlib.pyplot.legend` can then be
             used to see which is which).

             Any value of the `MeshFunction` that does not have a corresponding entry
             in `names` is ignored (for example, internal facets inside the domain).

             Thus, only facets whose tags are *whitelisted* by presence in `names` will be plotted.
             They will be labeled (for `legend`) as e.g. "INLET (ID#1)" where "INLET" is a name
             from `names`, and `1` is the corresponding tag value.

    `invalid_values`: Alternative for `names`.

                     If provided, these tag values will be ignored. Useful values:
                         [0] for a manually generated `MeshFunction`, and
                         [2**64 - 1] for Gmsh import via `meshio`.

                     Thus, all facets whose tags are *not blacklisted* by presence in `invalid_values`
                     will be plotted. They will be labeled (for `legend`) as "<boundary> (ID#X)",
                     where "X" is the tag value.

                     If `names` is provided, it takes precedence.

    No return value.
    """
    mesh = f.mesh()
    if mesh.topology().dim() != 2:
        raise NotImplementedError(f"This function only supports meshes of topological dimension 2, got {mesh.topology().dim()}")

    # Simplifying assumption: in geometric dimension 2, we can just discard the third coordinate of the vertices.
    if mesh.geometric_dimension() != 2:
        raise NotImplementedError(f"This function only supports meshes of geometric dimension 2, got {mesh.geometric_dimension()}")

    if f.dim() != 1:
        raise NotImplementedError(f"This function only supports mesh functions on facets (dimension 1); got a function of dimension {f.dim()}")
    if dolfin.MPI.comm_world.size > 1:
        # TODO: add MPI support.
        # Like the MPI plotter above, we should gather all data to the root process.
        # Not that important to implement, though, because mesh generation and import
        # (visualizing which is the primary use case for this function) is often done in serial mode.
        raise NotImplementedError("Facet meshfunction plotting currently only supported in serial mode.")

    if names:
        tag_to_name = {item.value: item.name for item in names}

    def empty_list() -> typing.List:
        return []
    plot_data = defaultdict(empty_list)
    for facet in dolfin.facets(mesh):
        tag = f[facet]
        ignore_tag = (names and tag not in tag_to_name) or (invalid_values is not None and tag in invalid_values)
        if not ignore_tag:
            vtxs = [vtx.point().array()[:2] for vtx in dolfin.vertices(facet)]  # [[x1, y1], [x2, y2]]
            plot_data[tag].append(vtxs)
            # Insert a NaN entry to force matplotlib to draw each facet separately,
            # instead of connecting them. (They are not in any useful order, and in general,
            # facets with the same tag need not form a connected line.)
            # https://stackoverflow.com/questions/21352580/matplotlib-plotting-numerous-disconnected-line-segments-with-different-colors
            plot_data[tag].append(np.array([[np.nan, np.nan]]))
    plot_data = {tag: np.concatenate(vtxss) for tag, vtxss in sorted(plot_data.items(), key=lambda item: item[0])}

    for tag, vtxs in plot_data.items():
        label = f"{tag_to_name[tag]} (ID#{tag})" if names else f"<boundary> (ID#{tag})"
        plt.plot(vtxs[:, 0], vtxs[:, 1], color=colors[tag % len(colors)], label=label)
